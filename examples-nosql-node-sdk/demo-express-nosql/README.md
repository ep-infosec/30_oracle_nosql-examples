# demo-express-nosql

## Deployment
1. Clone this repository

````
sudo yum install git
git clone https://github.com/oracle/nosql-examples.git
````

2. Create the table

````
cd ~/nosql-examples/examples-nosql-node-sdk/demo-express-nosql/express-nosql
kv_admin ddl.sql
````

3. SET the following env variables

````
export NOSQL_ENDPOINT=$HOSTNAME
export NOSQL_PORT=8080
````

4. Run

````
cd ~/nosql-examples/examples-nosql-node-sdk/demo-express-nosql/express-nosql
npm install
node express-oracle-nosql.js
````

## Deployment using docker connected to a NoSQL cluster

````
docker build -t express-nosql .
docker run --env NOSQL_ENDPOINT=$HOSTNAME -p 3000:3000  express-nosql 
````

## Deployment using docker and KVLite running in docker

1. Start up KVLite in a container

pull the image directly from the GitHub Container Registry:

```shell
docker pull ghcr.io/oracle/nosql:latest-ce
docker tag ghcr.io/oracle/nosql:latest-ce oracle/nosql:ce
```

Start up KVLite in a container. You must give it a name and provide a hostname. Startup of
KVLite is the default `CMD` of the image:

```shell
docker run -d --name=kvlite --hostname=kvlite --env KV_PROXY_PORT=8080 -p 8080:8080 oracle/nosql:ce
```

see instuction https://github.com/oracle/docker-images/tree/main/NoSQL

2. Deploy this application

````shell
docker build -t express-nosql .
````

Start up this demo in a container 

````shell
docker run -d --env NOSQL_ENDPOINT=$HOSTNAME -p 3000:3000 express-nosql 
````
or use user-defined bridge network name

````shell
docker run -d --link kvlite --env NOSQL_ENDPOINT=kvlite  -p 3000:3000 express-nosql 
````


This project offers sample container image to show how to connect a NoSQL application to Oracle NoSQL Database Proxy running in a container

The default values for the env variables are
````
ENV NOSQL_ENDPOINT kvlite
ENV NOSQL_PORT 8080
````

## TEST

1. USE CURL

````
curl -X POST -d '{"id": -1, "blog": "Creating an empty blog from Node.js"}' -H 'content-type: application/json' localhost:3000
curl -X POST -d '{"blog": "Creating an empty blog from Node.js"}' -H 'content-type: application/json' localhost:3000
curl -X GET http://localhost:3000/1005
curl -X DELETE http://localhost:3000/1005
curl -X GET http://localhost:3000/

````

If you created the table using GENERATED ALWAYS AS IDENTITY instead of GENERATED BY DEFAULT AS IDENTITY, you will have the following error when trying to run the 1st command
````
curl -X POST -d '{"id": -1, "blog": "Creating an empty blog from Node.js"}' -H 'content-type: application/json' localhost:3000 |jq
  "error": {
    "_errCode": {
      "_ordinal": 4,
      "_name": "ILLEGAL_ARGUMENT",
      "retryable": false
    },
    "name": "NoSQLArgumentError",
    "_req": {
      "tableName": "BlogTable",
      "row": {
        "id": -1,
        "blog": "Creating an empty blog from Node.js"
      },
      "opt": {
        "requestTimeout": 5000
      },
      "_auth": null
    },
    "_rejectedByDriver": false
  }
}

In the console

failed to insert data NoSQLArgumentError: [ILLEGAL_ARGUMENT] PUT: Illegal Argument: Value should not be set for a generated always identity column: id

````

You can also run the following test by adding more fields to your json parameter. You will see that only the fields in the table will be used to create the record.

````
NEW=`curl -X POST -d '{"blog": "Creating an empty blog from Node.js", "completed":true}' -H 'content-type: application/json' localhost:3000 2>/dev/null | jq '.result.generatedValue'`
echo $NEW
curl  http://localhost:3000/$NEW 2>/dev/null| jq

{
  "id": 1009,
  "blog": "Creating an empty blog from Node.js"
}

````
If you don't want this behavior, set the flag exactMatch to true in the opt parameter when calling the put function (https://oracle.github.io/nosql-node-sdk/NoSQLClient.html#put)
````
const result = await client.put("BlogTable", req.body, {exactMatch:true} );


failed to insert data NoSQLArgumentError: [ILLEGAL_ARGUMENT] PUT: Illegal Argument: There is no field with name completed

````

## TEST Running generic-express-oracle-nosql.js

show all tables

````
curl  http://localhost:3000/ | jq
{
  "tables": [
    "blogtable",
    "myTable",
    "People",
    "SYS$IndexStatsLease",
    "SYS$MRTableAgentStat",
    "SYS$MRTableInitCheckpoint",
    "SYS$PartitionStatsLease",
    "SYS$SGAttributesTable",
    "SYS$StreamRequest",
    "SYS$StreamResponse",
    "SYS$TableStatsIndex",
    "SYS$TableStatsPartition"
  ],
  "lastIndex": 12
}
````
show data for a specific table (e.g. myTable, people)

````
curl  http://localhost:3000/MyTable | jq
[
  {
    "id": 0,
    "labels": [
      {
        "contentType": "Salut",
        "etag": "Salut",
        "label": "b",
        "value": "Salut"
      }
    ]
  }
]

curl  http://localhost:3000/People | jq

[
  {
    "id": 0,
    "info": {
      "address": {
        "city": "San Fransisco",
        "phones": [],
        "state": "CA"
      },
      "children": {
        "Anna": {
          "age": 10,
          "friends": [
            "Anna",
            "John",
            "Maria"
          ],
          "school": "school_1"
        },
        "Mary": {
          "age": 7,
          "friends": [
            "Anna",
            "Mark"
          ],
          "school": "school_3"
        },
        "Ron": {
          "age": 2
        }
      },
      "firstName": "John",
      "income": 200000,
      "lastName": "Doe",
      "profession": "software engineer"
    }
  }
]
````

show data for a specific table using the limit and orderby parameter (e.g blogtable)

````
curl  http://localhost:3000/blogtable?limit=3 | jq

[
  {
    "id": 125,
    "blog": "Creating an empty blog tagged #124"
  },
  {
    "id": 336,
    "blog": "Creating an empty blog tagged #335"
  },
  {
    "id": 513,
    "blog": "Creating an empty blog tagged #512"
  }
]

curl  "http://localhost:3000/blogtable?limit=3&orderby=id"  | jq

[
  {
    "id": 1,
    "blog": "Creating an empty blog tagged #0"
  },
  {
    "id": 2,
    "blog": "Creating an empty blog tagged #1"
  },
  {
    "id": 3,
    "blog": "Creating an empty blog tagged #2"
  }
]


curl  "http://localhost:3000/blogtable?limit=12&orderby=blog"  | jq
[
  {
    "id": 1009,
    "blog": "Creating an empty blog from Node.js"
  },
  {
    "id": 1003,
    "blog": "Creating an empty blog tagged #-1"
  },
  {
    "id": 1,
    "blog": "Creating an empty blog tagged #0"
  },
  {
    "id": 2,
    "blog": "Creating an empty blog tagged #1"
  },
  {
    "id": 11,
    "blog": "Creating an empty blog tagged #10"
  },
  {
    "id": 101,
    "blog": "Creating an empty blog tagged #100"
  },
  {
    "id": 102,
    "blog": "Creating an empty blog tagged #101"
  },
  {
    "id": 103,
    "blog": "Creating an empty blog tagged #102"
  },
  {
    "id": 104,
    "blog": "Creating an empty blog tagged #103"
  },
  {
    "id": 105,
    "blog": "Creating an empty blog tagged #104"
  },
  {
    "id": 106,
    "blog": "Creating an empty blog tagged #105"
  },
  {
    "id": 107,
    "blog": "Creating an empty blog tagged #106"
  }
]


````

show table description (e.g people)


````
 curl  http://localhost:3000/People/desc
{
  "json_version" : 1,
  "type" : "table",
  "name" : "People",
  "fields" : [{
    "name" : "id",
    "type" : "INTEGER",
    "nullable" : false
  }, {
    "name" : "info",
    "type" : "JSON",
    "nullable" : true
  }],
  "primaryKey" : ["id"],
  "shardKey" : ["id"]
}
````



